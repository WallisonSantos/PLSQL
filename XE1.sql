
-- DIFERENTE DO IGUAL, O LIKE USA O CURINGA (%) PARA PEGAR TUDO QUE ANTECEDE OU PROCEDE;

SELECT * FROM tb_clientes WHERE endereco2 = NULL;

SELECT * FROM tb_clientes;

UPDATE TB_CLIENTES SET IDADE = 25 WHERE IDADE >=23;

UPDATE TB_PRODUTOS SET SABOR = 'Citrico' WHERE SABOR = 'CItrico';

UPDATE tb_produtos SET SABOR = 'Melancia' WHERE SABOR = 'Melancia';

SELECT * FROM tb_produtos WHERE TAMANHO LIKE '470%';

SELECT * FROM tb_produtos WHERE SABOR = 'Manga' AND TAMANHO LIKE '%470%'; -- SELECIONANDO SOMENTE DE ACORDO COM AS CONDIï¿½ï¿½ES

SELECT * FROM tb_produtos WHERE NOT(SABOR = 'Manga' OR TAMANHO LIKE '%5%' OR TAMANHO LIKE '%7%'); -- TRARA TUDO QUE ï¿½ DIF. DA EXPRESSï¿½O

-- IN: LIMITA A CONSULTA DE ACORDO COM OS RESPECTIVOS DADOS

SELECT * FROM tb_produtos WHERE SABOR IN('Laranja', 'Citrico');-- in funciona como se fosse um OR

SELECT * FROM TB_CLIENTES WHERE CIDADE IN('Rio de Janeiro', 'Sï¿½o Paulo') AND IDADE = 23;

SELECT * FROM TB_CLIENTES WHERE CIDADE IN('Sï¿½o Paulo', 'Rio de Janeiro') AND IDADE >=2 AND IDADE <= 22 ORDER BY IDADE;

SELECT * FROM TB_PRODUTOS WHERE SABOR LIKE '%M%' and embalagem = 'Garrafa';

-- DISTINCT: IrÃ¡ retornar linhas com valores diferentes. Linhas exclusivas,

SELECT DISTINCT * FROM tb_produtos WHERE EMBALAGEM = 'PET' and preco_lista >= 20 OR SABOR LIKE '%Açai%';

-- ROWNUM: Número de Linhas

SELECT ROWNUM PRODUTO, NOME FROM TB_PRODUTOS;

SELECT ROWNUM PRODUTO, NOME FROM TB_PRODUTOS WHERE ROWNUM <=5;

-- ORDER BY: ORDENAR UMA TABELA,

SELECT * FROM tb_produtos WHERE EMBALAGEM = 'PET' ORDER BY preco_lista; -- ORDENAR POR VALOR DE PREÇO

SELECT * FROM TB_PRODUTOS ORDER BY SABOR DESC, NOME ASC;

SELECT * FROM tb_produtos;

UPDATE tb_clientes SET BAIRRO = 'Lapa SP' WHERE BAIRRO = 'Lapa';

-- AGRUPANDO OS RESULTADOS USANDO SOMAS, MAX, MIN ...

SELECT ESTADO, CIDADE, SUM(LIMITE_CREDITO) AS LIM FROM TB_CLIENTES GROUP BY ESTADO, CIDADE;

SELECT EMBALAGEM, TAMANHO, MAX(PRECO_LISTA) AS MAX FROM TB_PRODUTOS GROUP BY EMBALAGEM, TAMANHO;

SELECT EMBALAGEM, MAX(PRECO_LISTA) AS MAX FROM TB_PRODUTOS GROUP BY EMBALAGEM;

SELECT BAIRRO, MIN(LIMITE_CREDITO) AS MIN FROM tb_clientes GROUP BY BAIRRO;

-- USANDO CONDICIONAIS, CASE, WHEN ..

SELECT NOME, PRECO_LISTA,
(CASE WHEN PRECO_LISTA >= 12 THEN 'PRODUTO CARO'
WHEN PRECO_LISTA >=7 AND PRECO_LISTA < 12 THEN 'PRODUTO EM CONTA'
ELSE 'PRODUTO BARATO'
END) AS STATUS_PRECO FROM TB_PRODUTOS;

SELECT EMBALAGEM,
(CASE WHEN PRECO_LISTA >= 12 THEN 'PRODUTO CARO'
WHEN PRECO_LISTA >= 7 AND PRECO_LISTA < 12 THEN 'PRODUTO EM CONTA'
ELSE 'PRODUTO BARATO'
END) AS STATUS_PRECO,
AVG(PRECO_LISTA) AS MEDIA_PRECO
FROM TB_PRODUTOS
GROUP BY EMBALAGEM,
(CASE WHEN PRECO_LISTA >= 12 THEN 'PRODUTO CARO'
WHEN PRECO_LISTA >= 7 AND PRECO_LISTA < 12 THEN 'PRODUTO EM CONTA'
ELSE 'PRODUTO BARATO'
END);

-- HAVING: O HAVING é uma condição (Filtro) que se aplica ao resultado de uma agregação;

SELECT ESTADO, SUM(LIMITE_CREDITO) AS SOMA
FROM tb_clientes
GROUP BY ESTADO
HAVING SUM(LIMITE_CREDITO) >= 900000;

SELECT EMBALAGEM,
    MAX(PRECO_LISTA) AS MAIOR_PRECO,
    MIN(PRECO_LISTA) AS MENOR_PRECO,
    AVG(PRECO_LISTA) AS MEDIA_PRECO
    FROM TB_PRODUTOS
    GROUP BY EMBALAGEM
    HAVING SUM(PRECO_LISTA) <= 80;

SELECT CPF, COUNT(*) FROM TB_CLIENTES WHERE TO_CHAR(DATA_NASCIMENTO, 'YYYY') = '2016' GROUP BY CPF HAVING COUNT(*) > 2000;

SELECT DISTINCT SABOR FROM TB_PRODUTOS WHERE SABOR = 'Laranja';

SELECT DISTINCT EMBALAGEM, SABOR FROM TB_PRODUTOS;

SELECT ROWNUM,
PRODUTO,
NOME FROM
TB_PRODUTOS
WHERE ROWNUM <= 5;

SELECT * FROM TB_PRODUTOS ORDER BY PRECO_LISTA DESC;

SELECT * FROM TB_CLIENTES ORDER BY NOME DESC;

SELECT * FROM TB_PRODUTOS ORDER BY EMBALAGEM DESC, NOME ASC;

SELECT ESTADO, LIMITE_CREDITO FROM TB_CLIENTES ORDER BY LIMITE_CREDITO ASC;

SELECT ESTADO, SUM(LIMITE_CREDITO) AS TOTAL FROM TB_CLIENTES GROUP BY ESTADO HAVING SUM(LIMITE_CREDITO) >= 900000;

SELECT EMBALAGEM, MAX(PRECO_LISTA) AS PR FROM TB_PRODUTOS GROUP BY EMBALAGEM;

SELECT EMBALAGEM, COUNT(*) AS NUMERO_PRODUTOS FROM TB_PRODUTOS GROUP BY EMBALAGEM HAVING SUM(PRECO_LISTA) >= 9;

SELECT BAIRRO, SUM(LIMITE_CREDITO) AS TOTAL FROM TB_CLIENTES WHERE CIDADE = 'Rio de Janeiro' GROUP BY BAIRRO ORDER BY TOTAL ASC;

SELECT ESTADO, BAIRRO, SUM(LIMITE_CREDITO) AS TOTAL FROM TB_CLIENTES GROUP BY ESTADO, BAIRRO ORDER BY TOTAL, ESTADO, BAIRRO;

SELECT ESTADO, SUM(LIMITE_CREDITO) AS SOMA FROM TB_CLIENTES GROUP BY ESTADO HAVING SUM(LIMITE_CREDITO) > 900000;

SELECT EMBALAGEM, MAX(PRECO_LISTA) AS MAIOR_PRECO, MIN(PRECO_LISTA) AS MENOR FROM TB_PRODUTOS GROUP BY EMBALAGEM HAVING SUM(PRECO_LISTA) <= 90000;

SELECT * FROM tb_produtos;


SELECT NOME,
PRECO_LISTA,
(CASE WHEN PRECO_LISTA >= 12 THEN 'PRODUTO CARO'
    WHEN PRECO_LISTA >= 7 AND PRECO_LISTA < 12 THEN 'PRODUTO EM CONTA'
    ELSE 'PRODUTO BARATO' END) AS PRECO FROM tb_produtos WHERE SABOR LIKE '%Ma%';

ALTER TABLE TB_VENDEDORES MODIFY (DATA_ADMISSAO DATE);

INSERT INTO TB_VENDEDORES(
    MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO, DE_FERIAS, BAIRRO
) VALUES (
    '00235', 'Marcio Almeida Silva', 0.8, TO_DATE('15/08/2014', 'DD/MM/YYYY'), 0, 'Tijuca'
);

INSERT INTO TB_VENDEDORES(
    MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO, DE_FERIAS, BAIRRO
) VALUES (
    '00236', 'Claudia Morais', 0.08, TO_DATE('17/09/2013', 'DD/MM/YYYY'), 1, 'Jardins'
);

INSERT INTO TB_VENDEDORES(
    MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO, DE_FERIAS, BAIRRO
) VALUES (
    '00237', 'Roberta Morais', 0.11, TO_DATE('18/03/2017', 'DD/MM/YYYY'), 0, 'Copacabana'
);

INSERT INTO TB_VENDEDORES(
    MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO, DE_FERIAS, BAIRRO
) VALUES (
    '00238', 'Pericles Alves', 0.11, TO_DATE('21/08/2016', 'DD/MM/YYYY'), 0, 'Santo Amaro'
);

UPDATE TB_VENDEDORES SET PERCENTUAL_COMISSAO = 0.08 WHERE MATRICULA = '00235';

UPDATE TB_NOTAS SET NUMERO = 110 WHERE CPF = '77712764423' AND matricula = '00234';

INSERT INTO TB_NOTAS;

CREATE TABLE TB_NOTAS
(CPF VARCHAR(11),
MATRICULA VARCHAR(10),
DATA_VENDA DATE,
NUMERO INT,
IMPOSTO FLOAT)

INSERT INTO TB_NOTAS(
    CPF, MATRICULA, DATA_VENDA, NUMERO, IMPOSTO
) VALUES (
    '2600586709', '00235', TO_DATE('10/11/2016', 'DD/MM/YYYY'), 115, 0.10
);

SELECT MATRICULA, COUNT(*) AS NUMERO_DE_NOTAS FROM TB_NOTAS GROUP BY MATRICULA ORDER BY NUMERO_DE_NOTAS;

-- JOIN's: POSSIBILIDADE DE UNIR UMA OU MAIS TABELAS ATRAVÉS DE CAMPO EM COMUM
-- EXISTEM VARIOS TIPOS DE JOINS QUE UREMOS VER AGORA;
-- INNER JOIN SÓ RETORNA QUANDO TEMOS CHAVES CORRESOONDENTES
-- LEFT JOIN: Retorna todos da Tabela da ESQUERDA e Somente os Correspondentes na da DIREITA
-- RIGHT JOIN: Retorna todos da Tabela da DIREITA e Somente os Correspondentes na da DIREITA
SELECT count(*) from tb_clientes;
SELECT CPF, COUNT(*) FROM TB_NOTAS GROUP BY CPF;
SELECT * FROM tb_clientes LEFT JOIN TB_NOTAS

SELECT a.matricula, b.nome, COUNT(*) FROM TB_NOTAS A
INNER JOIN TB_VENDEDORES B
-- Pegando o Campo Matricula da Tabela A que é Notas Fiscais, e igualando com o Campo Matricula da Tabela B, que é Tabela Vendedores
-- Com isto juntamos as duas Tabelas
ON a.matricula = b.matricula
GROUP BY A.MATRICULA, B.NOME

SELECT a.matricula, b.nome, b.data_admissao, count(*) FROM TB_NOTAS A
INNER JOIN TB_VENDEDORES B
ON a.matricula = b.matricula
GROUP BY a.matricula, b.nome, b.data_admissao

-- TODOS DA TAB DA ESQUERDA QUE TEM OCORRENCIA NA DIREITA, IRA TRAZER TODOS OS DADOS DA TABLE ESQUERDA
-- E TBM OS DADOS DA TB DIREITA QUE CORRESPONDEM AO MESMO CPA
SELECT B.CPF AS CPF_NOTAS,
A.NOME, A.CPF AS CPF_CLIENTE,
B.NUMERO AS NOTA, COUNT(*)
FROM TB_CLIENTES A LEFT JOIN TB_NOTAS B
ON A.CPF = B.CPF GROUP BY B.CPF, A.NOME, A.CPF, B.NUMERO;

SELECT B.CPF AS CPF_NOTAS,
A.NOME, A.CPF AS CPF_CLIENTE,
B.NUMERO AS NOTA
FROM TB_NOTAS B LEFT JOIN TB_CLIENTES A
ON A.CPF = B.CPF;

SELECT * FROM TB_NOTAS;
SELECT * FROM TB_VENDEDORES;
SELECT * FROM TB_CLIENTES;

SELECT
    C.NOME AS NOME_CLI,
    V.NOME AS NOME_VEN,
    C.BAIRRO AS BAIRRO_CLI,
    V.BAIRRO AS BAIRRO_VEN,
    C.ESTADO AS ESTADO_CLI
FROM
    TB_CLIENTES C
    INNER JOIN TB_VENDEDORES V
    ON C.BAIRRO = V.BAIRRO

SELECT
    TB_VENDEDORES.NOME AS NOME_VENDEDOR,
    TB_VENDEDORES.BAIRRO AS NOME_BAIRRO,
    TB_CLIENTES.NOME AS NOME_CLIENTE,
    TB_CLIENTES.BAIRRO AS BAIRRO_CLIENTE
FROM
    TB_VENDEDORES
    INNER JOIN TB_CLIENTES
    ON TB_VENDEDORES.BAIRRO = TB_CLIENTES.BAIRRO;
    
SELECT
    TB_VENDEDORES.NOME AS NOME_VENDEDOR,
    TB_VENDEDORES.BAIRRO AS NOME_BAIRRO,
    TB_CLIENTES.NOME AS NOME_CLIENTE,
    TB_CLIENTES.BAIRRO AS BAIRRO_CLIENTE
FROM
    TB_VENDEDORES
    RIGHT JOIN TB_CLIENTES
    ON TB_VENDEDORES.BAIRRO = TB_CLIENTES.BAIRRO;

-- TRAS LEFT E RIGHT AO MESMO TEMPO ...
SELECT
    TB_VENDEDORES.NOME AS NOME_VENDEDOR,
    TB_VENDEDORES.BAIRRO AS NOME_BAIRRO,
    TB_CLIENTES.NOME AS NOME_CLIENTE,
    TB_CLIENTES.BAIRRO AS BAIRRO_CLIENTE
FROM
    TB_VENDEDORES
    FULL JOIN TB_CLIENTES
    ON TB_VENDEDORES.BAIRRO = TB_CLIENTES.BAIRRO;

-- CROSS JOIN: NÃO HA UMA RELAÇÃO, INTERSECÇÃO UNIÃO ...
SELECT
    TB_VENDEDORES.NOME AS NOME_VENDEDOR,
    TB_VENDEDORES.BAIRRO AS NOME_BAIRRO,
    TB_CLIENTES.NOME AS NOME_CLIENTE,
    TB_CLIENTES.BAIRRO AS BAIRRO_CLIENTE
FROM
    TB_VENDEDORES,
    TB_CLIENTES

-- UNION: FAZ A UNIÃO DE DUAS OU MAIS TABELAS, É IMPORTANTE QUE AS TABELAS QUE SERÃO UNIDAS
-- TENHAM O MESMO NÚMERO E TIPO DE CAMPO, TEMOS DOI TIPO DE UNION, O SIMPLES E O ALL,
-- SIMPLES, SE HOUVER REGISTROS IGUAIS TANTO NA PRIMEIRA QUANTO NA SEGUNDA ELE IRÁ RESUMIR EM UMA LINHA SÓ, JÁ O ALL REPETE.


SELECT
    DISTINCT BAIRRO AS BAIRRO_CLIENTE, 'CLIENTE' AS TIPO
FROM
    TB_CLIENTES
UNION ALL
    SELECT
        DISTINCT BAIRRO AS BAIRRO_VENDEDOR, 'VENDEDOR' AS TIPO
    FROM
        TB_VENDEDORES;




