
-- DIFERENTE DO IGUAL, O LIKE USA O CURINGA (%) PARA PEGAR TUDO QUE ANTECEDE OU PROCEDE;

SELECT * FROM tb_clientes WHERE endereco2 = NULL;

SELECT * FROM tb_clientes;

UPDATE TB_CLIENTES SET IDADE = 25 WHERE IDADE >=23;

UPDATE TB_PRODUTOS SET SABOR = 'Citrico' WHERE SABOR = 'CItrico';

UPDATE tb_produtos SET SABOR = 'Melancia' WHERE SABOR = 'Melancia';

SELECT * FROM tb_produtos WHERE TAMANHO LIKE '470%';

SELECT * FROM tb_produtos WHERE SABOR = 'Manga' AND TAMANHO LIKE '%470%'; -- SELECIONANDO SOMENTE DE ACORDO COM AS CONDIï¿½ï¿½ES

SELECT * FROM tb_produtos WHERE NOT(SABOR = 'Manga' OR TAMANHO LIKE '%5%' OR TAMANHO LIKE '%7%'); -- TRARA TUDO QUE ï¿½ DIF. DA EXPRESSï¿½O

-- IN: LIMITA A CONSULTA DE ACORDO COM OS RESPECTIVOS DADOS

SELECT * FROM tb_produtos WHERE SABOR IN('Laranja', 'Citrico');-- in funciona como se fosse um OR

SELECT * FROM TB_CLIENTES WHERE CIDADE IN('Rio de Janeiro', 'Sï¿½o Paulo') AND IDADE = 23;

SELECT * FROM TB_CLIENTES WHERE CIDADE IN('Sï¿½o Paulo', 'Rio de Janeiro') AND IDADE >=2 AND IDADE <= 22 ORDER BY IDADE;

SELECT * FROM TB_PRODUTOS WHERE SABOR LIKE '%M%' and embalagem = 'Garrafa';

-- DISTINCT: IrÃ¡ retornar linhas com valores diferentes. Linhas exclusivas,

SELECT DISTINCT * FROM tb_produtos WHERE EMBALAGEM = 'PET' and preco_lista >= 20 OR SABOR LIKE '%Açai%';

-- ROWNUM: Número de Linhas

SELECT ROWNUM PRODUTO, NOME FROM TB_PRODUTOS;

SELECT ROWNUM PRODUTO, NOME FROM TB_PRODUTOS WHERE ROWNUM <=5;

-- ORDER BY: ORDENAR UMA TABELA,

SELECT * FROM tb_produtos WHERE EMBALAGEM = 'PET' ORDER BY preco_lista; -- ORDENAR POR VALOR DE PREÇO

SELECT * FROM TB_PRODUTOS ORDER BY SABOR DESC, NOME ASC;

SELECT * FROM tb_produtos;

UPDATE tb_clientes SET BAIRRO = 'Lapa SP' WHERE BAIRRO = 'Lapa';

-- AGRUPANDO OS RESULTADOS USANDO SOMAS, MAX, MIN ...

SELECT ESTADO, CIDADE, SUM(LIMITE_CREDITO) AS LIM FROM TB_CLIENTES GROUP BY ESTADO, CIDADE;

SELECT EMBALAGEM, TAMANHO, MAX(PRECO_LISTA) AS MAX FROM TB_PRODUTOS GROUP BY EMBALAGEM, TAMANHO;

SELECT EMBALAGEM, MAX(PRECO_LISTA) AS MAX FROM TB_PRODUTOS GROUP BY EMBALAGEM;

SELECT BAIRRO, MIN(LIMITE_CREDITO) AS MIN FROM tb_clientes GROUP BY BAIRRO;

-- USANDO CONDICIONAIS, CASE, WHEN ..

SELECT NOME, PRECO_LISTA,
(CASE WHEN PRECO_LISTA >= 12 THEN 'PRODUTO CARO'
WHEN PRECO_LISTA >=7 AND PRECO_LISTA < 12 THEN 'PRODUTO EM CONTA'
ELSE 'PRODUTO BARATO'
END) AS STATUS_PRECO FROM TB_PRODUTOS;

SELECT EMBALAGEM,
(CASE WHEN PRECO_LISTA >= 12 THEN 'PRODUTO CARO'
WHEN PRECO_LISTA >= 7 AND PRECO_LISTA < 12 THEN 'PRODUTO EM CONTA'
ELSE 'PRODUTO BARATO'
END) AS STATUS_PRECO,
AVG(PRECO_LISTA) AS MEDIA_PRECO
FROM TB_PRODUTOS
GROUP BY EMBALAGEM,
(CASE WHEN PRECO_LISTA >= 12 THEN 'PRODUTO CARO'
WHEN PRECO_LISTA >= 7 AND PRECO_LISTA < 12 THEN 'PRODUTO EM CONTA'
ELSE 'PRODUTO BARATO'
END);

-- HAVING: O HAVING é uma condição (Filtro) que se aplica ao resultado de uma agregação;

SELECT ESTADO, SUM(LIMITE_CREDITO) AS SOMA
FROM tb_clientes
GROUP BY ESTADO
HAVING SUM(LIMITE_CREDITO) >= 900000;

SELECT EMBALAGEM,
    MAX(PRECO_LISTA) AS MAIOR_PRECO,
    MIN(PRECO_LISTA) AS MENOR_PRECO,
    AVG(PRECO_LISTA) AS MEDIA_PRECO
    FROM TB_PRODUTOS
    GROUP BY EMBALAGEM
    HAVING SUM(PRECO_LISTA) <= 80;

SELECT CPF, COUNT(*) FROM TB_CLIENTES WHERE TO_CHAR(DATA_NASCIMENTO, 'YYYY') = '2016' GROUP BY CPF HAVING COUNT(*) > 2000;

SELECT DISTINCT SABOR FROM TB_PRODUTOS WHERE SABOR = 'Laranja';

SELECT DISTINCT EMBALAGEM, SABOR FROM TB_PRODUTOS;

SELECT ROWNUM,
PRODUTO,
NOME FROM
TB_PRODUTOS
WHERE ROWNUM <= 5;

SELECT * FROM TB_PRODUTOS ORDER BY PRECO_LISTA DESC;

SELECT * FROM TB_CLIENTES ORDER BY NOME DESC;

SELECT * FROM TB_PRODUTOS ORDER BY EMBALAGEM DESC, NOME ASC;

SELECT ESTADO, LIMITE_CREDITO FROM TB_CLIENTES ORDER BY LIMITE_CREDITO ASC;

SELECT ESTADO, SUM(LIMITE_CREDITO) AS TOTAL FROM TB_CLIENTES GROUP BY ESTADO HAVING SUM(LIMITE_CREDITO) >= 900000;

SELECT EMBALAGEM, MAX(PRECO_LISTA) AS PR FROM TB_PRODUTOS GROUP BY EMBALAGEM;

SELECT EMBALAGEM, COUNT(*) AS NUMERO_PRODUTOS FROM TB_PRODUTOS GROUP BY EMBALAGEM HAVING SUM(PRECO_LISTA) >= 9;

SELECT BAIRRO, SUM(LIMITE_CREDITO) AS TOTAL FROM TB_CLIENTES WHERE CIDADE = 'Rio de Janeiro' GROUP BY BAIRRO ORDER BY TOTAL ASC;

SELECT ESTADO, BAIRRO, SUM(LIMITE_CREDITO) AS TOTAL FROM TB_CLIENTES GROUP BY ESTADO, BAIRRO ORDER BY TOTAL, ESTADO, BAIRRO;

SELECT ESTADO, SUM(LIMITE_CREDITO) AS SOMA FROM TB_CLIENTES GROUP BY ESTADO HAVING SUM(LIMITE_CREDITO) > 900000;

SELECT EMBALAGEM, MAX(PRECO_LISTA) AS MAIOR_PRECO, MIN(PRECO_LISTA) AS MENOR FROM TB_PRODUTOS GROUP BY EMBALAGEM HAVING SUM(PRECO_LISTA) <= 90000;

SELECT * FROM tb_produtos;


SELECT NOME,
PRECO_LISTA,
(CASE WHEN PRECO_LISTA >= 12 THEN 'PRODUTO CARO'
    WHEN PRECO_LISTA >= 7 AND PRECO_LISTA < 12 THEN 'PRODUTO EM CONTA'
    ELSE 'PRODUTO BARATO' END) AS PRECO FROM tb_produtos WHERE SABOR LIKE '%Ma%';

ALTER TABLE TB_VENDEDORES MODIFY (DATA_ADMISSAO DATE);

INSERT INTO TB_VENDEDORES(
    MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO, DE_FERIAS, BAIRRO
) VALUES (
    '00235', 'Marcio Almeida Silva', 0.8, TO_DATE('15/08/2014', 'DD/MM/YYYY'), 0, 'Tijuca'
);

INSERT INTO TB_VENDEDORES(
    MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO, DE_FERIAS, BAIRRO
) VALUES (
    '00236', 'Claudia Morais', 0.08, TO_DATE('17/09/2013', 'DD/MM/YYYY'), 1, 'Jardins'
);

INSERT INTO TB_VENDEDORES(
    MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO, DE_FERIAS, BAIRRO
) VALUES (
    '00237', 'Roberta Morais', 0.11, TO_DATE('18/03/2017', 'DD/MM/YYYY'), 0, 'Copacabana'
);

INSERT INTO TB_VENDEDORES(
    MATRICULA, NOME, PERCENTUAL_COMISSAO, DATA_ADMISSAO, DE_FERIAS, BAIRRO
) VALUES (
    '00238', 'Pericles Alves', 0.11, TO_DATE('21/08/2016', 'DD/MM/YYYY'), 0, 'Santo Amaro'
);

UPDATE TB_VENDEDORES SET PERCENTUAL_COMISSAO = 0.08 WHERE MATRICULA = '00235';

UPDATE TB_NOTAS SET NUMERO = 110 WHERE CPF = '77712764423' AND matricula = '00234';

INSERT INTO TB_NOTAS;

CREATE TABLE TB_NOTAS
(CPF VARCHAR(11),
MATRICULA VARCHAR(10),
DATA_VENDA DATE,
NUMERO INT,
IMPOSTO FLOAT)

INSERT INTO TB_NOTAS(
    CPF, MATRICULA, DATA_VENDA, NUMERO, IMPOSTO
) VALUES (
    '2600586709', '00235', TO_DATE('10/11/2016', 'DD/MM/YYYY'), 115, 0.10
);

SELECT MATRICULA, COUNT(*) AS NUMERO_DE_NOTAS FROM TB_NOTAS GROUP BY MATRICULA ORDER BY NUMERO_DE_NOTAS;

-- JOIN's: POSSIBILIDADE DE UNIR UMA OU MAIS TABELAS ATRAVÉS DE CAMPO EM COMUM
-- EXISTEM VARIOS TIPOS DE JOINS QUE UREMOS VER AGORA;
-- INNER JOIN SÓ RETORNA QUANDO TEMOS CHAVES CORRESOONDENTES
-- LEFT JOIN: Retorna todos da Tabela da ESQUERDA e Somente os Correspondentes na da DIREITA
-- RIGHT JOIN: Retorna todos da Tabela da DIREITA e Somente os Correspondentes na da DIREITA
SELECT count(*) from tb_clientes;
SELECT CPF, COUNT(*) FROM TB_NOTAS GROUP BY CPF;
SELECT * FROM tb_clientes LEFT JOIN TB_NOTAS

SELECT a.matricula, b.nome, COUNT(*) FROM TB_NOTAS A
INNER JOIN TB_VENDEDORES B
-- Pegando o Campo Matricula da Tabela A que é Notas Fiscais, e igualando com o Campo Matricula da Tabela B, que é Tabela Vendedores
-- Com isto juntamos as duas Tabelas
ON a.matricula = b.matricula
GROUP BY A.MATRICULA, B.NOME

SELECT a.matricula, b.nome, b.data_admissao, count(*) FROM TB_NOTAS A
INNER JOIN TB_VENDEDORES B
ON a.matricula = b.matricula
GROUP BY a.matricula, b.nome, b.data_admissao

-- TODOS DA TAB DA ESQUERDA QUE TEM OCORRENCIA NA DIREITA, IRA TRAZER TODOS OS DADOS DA TABLE ESQUERDA
-- E TBM OS DADOS DA TB DIREITA QUE CORRESPONDEM AO MESMO CPA
SELECT B.CPF AS CPF_NOTAS,
A.NOME, A.CPF AS CPF_CLIENTE,
B.NUMERO AS NOTA, COUNT(*)
FROM TB_CLIENTES A LEFT JOIN TB_NOTAS B
ON A.CPF = B.CPF GROUP BY B.CPF, A.NOME, A.CPF, B.NUMERO;

SELECT B.CPF AS CPF_NOTAS,
A.NOME, A.CPF AS CPF_CLIENTE,
B.NUMERO AS NOTA
FROM TB_NOTAS B LEFT JOIN TB_CLIENTES A
ON A.CPF = B.CPF;

SELECT
    C.NOME AS NOME_CLI,
    V.NOME AS NOME_VEN,
    C.BAIRRO AS BAIRRO_CLI,
    V.BAIRRO AS BAIRRO_VEN,
    C.ESTADO AS ESTADO_CLI
FROM
    TB_CLIENTES C
    INNER JOIN TB_VENDEDORES V
    ON C.BAIRRO = V.BAIRRO

SELECT
    TB_VENDEDORES.NOME AS NOME_VENDEDOR,
    TB_VENDEDORES.BAIRRO AS NOME_BAIRRO,
    TB_CLIENTES.NOME AS NOME_CLIENTE,
    TB_CLIENTES.BAIRRO AS BAIRRO_CLIENTE
FROM
    TB_VENDEDORES
    INNER JOIN TB_CLIENTES
    ON TB_VENDEDORES.BAIRRO = TB_CLIENTES.BAIRRO;
    
SELECT
    TB_VENDEDORES.NOME AS NOME_VENDEDOR,
    TB_VENDEDORES.BAIRRO AS NOME_BAIRRO,
    TB_CLIENTES.NOME AS NOME_CLIENTE,
    TB_CLIENTES.BAIRRO AS BAIRRO_CLIENTE
FROM
    TB_VENDEDORES
    RIGHT JOIN TB_CLIENTES
    ON TB_VENDEDORES.BAIRRO = TB_CLIENTES.BAIRRO;

-- TRAS LEFT E RIGHT AO MESMO TEMPO ...
SELECT
    TB_VENDEDORES.NOME AS NOME_VENDEDOR,
    TB_VENDEDORES.BAIRRO AS NOME_BAIRRO,
    TB_CLIENTES.NOME AS NOME_CLIENTE,
    TB_CLIENTES.BAIRRO AS BAIRRO_CLIENTE
FROM
    TB_VENDEDORES
    FULL JOIN TB_CLIENTES
    ON TB_VENDEDORES.BAIRRO = TB_CLIENTES.BAIRRO;

-- CROSS JOIN: NÃO HA UMA RELAÇÃO, INTERSECÇÃO UNIÃO ...
SELECT
    TB_VENDEDORES.NOME AS NOME_VENDEDOR,
    TB_VENDEDORES.BAIRRO AS NOME_BAIRRO,
    TB_CLIENTES.NOME AS NOME_CLIENTE,
    TB_CLIENTES.BAIRRO AS BAIRRO_CLIENTE
FROM
    TB_VENDEDORES,
    TB_CLIENTES

-- UNION: FAZ A UNIÃO DE DUAS OU MAIS TABELAS, É IMPORTANTE QUE AS TABELAS QUE SERÃO UNIDAS
-- TENHAM O MESMO NÚMERO E TIPO DE CAMPO, TEMOS DOI TIPO DE UNION, O SIMPLES E O ALL,
-- SIMPLES, SE HOUVER REGISTROS IGUAIS TANTO NA PRIMEIRA QUANTO NA SEGUNDA ELE IRÁ RESUMIR EM UMA LINHA SÓ, JÁ O ALL REPETE.


SELECT
    DISTINCT BAIRRO AS BAIRRO_CLIENTE, 'CLIENTE' AS TIPO
FROM
    TB_CLIENTES
UNION ALL
    SELECT
        DISTINCT BAIRRO AS BAIRRO_VENDEDOR, 'VENDEDOR' AS TIPO
    FROM
        TB_VENDEDORES;

-- SUBCONSULTAS: FACILITAM ESTE TIPO DE CONSULTA; qual queremos especificar a consulta a partir de outra seleção especifica...
-- SELECÇÃO ESPECIFICA PARA A CONSULTA NA BASE TB_CLIENTES
select distinct BAIRRO FROM TB_VENDEDORES;
-- BASE TB_CLIENTES QUAL IREMOS CONSULTAR:
SELECT * FROM TB_CLIENTES WHERE BAIRRO
IN('Tijuca', 'Santo Amaro', 'Jardins', 'Copacabana');

-- FORMA PRATICA DE SE FAZER A SUBCONSULTA:
SELECT * FROM tb_clientes WHERE BAIRRO
    IN(SELECT DISTINCT BAIRRO FROM TB_VENDEDORES);

SELECT Z.EMBALAGEM, Z.SOMA_PRECO FROM  
(SELECT EMBALAGEM, SUM(PRECO_LISTA) AS SOMA_PRECO
FROM TB_PRODUTOS GROUP BY EMBALAGEM) Z
WHERE z.soma_preco <= 80;

SELECT
    EMBALAGEM
    , TAMANHO
    , SUM(PRECO_LISTA) AS SOMA
    , AVG(PRECO_LISTA) AS MEDI
    , MAX(PRECO_LISTA) AS MAXI
FROM
    TB_PRODUTOS
GROUP BY
    EMBALAGEM
    , TAMANHO;

-- USANDO VIEW's PARA RELACIONAR TABELAS

SELECT *FROM VW_EMBALAGENS WHERE EMBALAGEM LIKE '%rrafa%';

SELECT
* FROM
    TB_PRODUTOS A
    INNER JOIN VW_EMBALAGENS B
    ON a.embalagem = b.embalagem
WHERE
    SABOR LIKE '%Mela%'

-- FUNÇÕES:

SELECT NOME, UPPER(NOME)  FROM TB_CLIENTES;

SELECT NOME, LOWER(NOME) FROM TB_CLIENTES;

SELECT NOME, INITCAP(NOME) AS M FROM TB_PRODUTOS;

SELECT CONCAT(CPF, MATRICULA) AS CONCATENAR FROM TB_NOTAS;

SELECT NOME, 'Endereço: ' || ENDERECO1 || ' ' || BAIRRO || ' ' || CIDADE || ' ' || ESTADO || ', CEP: ' || CEP
AS CONCATENAR FROM TB_CLIENTES;

SELECT NOME, LPAD(NOME, 60, '*') FROM TB_PRODUTOS;

SELECT NOME, SUBSTR(NOME, 3, 20), LPAD(NOME, 60, '*') FROM TB_PRODUTOS;

SELECT NOME, INSTR(NOME, '-') FROM TB_PRODUTOS;

SELECT LTRIM('           AAAAAAA') FROM DUAL;

SELECT RTRIM('AAAAAAAA                 ') FROM DUAL;

SELECT NOME, REPLACE(NOME, 'Litros', 'L') from tb_produtos;

-- USANDO DATAS:

SELECT TO_CHAR(SYSDATE, 'YYYY HH:MM:SS') FROM DUAL;

SELECT SYSDATE + 10 FROM DUAL;

SELECT MONTHS_BETWEEN(SYSDATE, TO_DATE('2021-10-01', 'YYYY-MM-DD')) FROM DUAL;

SELECT ADD_MONTHS(SYSDATE, 10) FROM DUAL;

SELECT NEXT_DAY(SYSDATE, 'SEXTA') FROM DUAL;

SELECT LAST_DAY(SYSDATE) FROM DUAL;

SELECT TRUNC(SYSDATE, 'YEAR') FROM DUAL;

SELECT TRUNC(SYSDATE, 'MONTH') FROM DUAL;

SELECT ROUND(SYSDATE - 10 , 'MONTH') FROM DUAL;

SELECT NOME, ROUND(MONTHS_BETWEEN(SYSDATE, DATA_NASCIMENTO)/12) AS IDADE FROM TB_CLIENTES;

--FUNÇÕES MATEMATICAS

SELECT ROUND(3.4) FROM DUAL;

SELECT ROUND(3.5) FROM DUAL;

SELECT TRUNC(3.4) FROM DUAL;

SELECT TRUNC(3.6) FROM DUAL;

SELECT CEIL(3.4) FROM DUAL;

SELECT CEIL(3.6) FROM DUAL;

SELECT FLOOR(3.4) FROM DUAL;

SELECT FLOOR(3.6) FROM DUAL;

SELECT POWER(10, 4) FROM DUAL;

SELECT EXP(10) FROM DUAL;

SELECT SQRT(10) FROM DUAL;

SELECT SQRT(144) FROM DUAL;

SELECT SIGN(-10) FROM DUAL;

SELECT SIGN(10) FROM DUAL;

SELECT ABS(-10000) FROM DUAL;

SELECT ABS(10000) FROM DUAL;

SELECT MOD(10, 6) FROM DUAL;

-- CONVERSÃO DE DADOS:

SELECT TO_DATE('12/12/2020', 'DD/MM/YYYY') FROM DUAL;

select to_date('12/01/2020', 'MM/DD/YYYY') FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'DD/MM/YYYY HH12:MM:SS PM') FROM DUAL;

SELECT EXTRACT(MONTH FROM TO_DATE('12/01/2020', 'DD/MM/YYYY')) FROM DUAL;

SELECT EXTRACT(MONTH FROM TO_DATE('12/01/2020', 'MM/DD/YYYY')) FROM DUAL;

SELECT TO_NUMBER('10') + 100 FROM DUAL;

SELECT TO_CHAR(10, '00000') FROM DUAL; -- DIGITAR ZEROS PARA COMPLETAR 5 DIGITOS

SELECT NVL(10, 0) FROM DUAL;

-- NVL:

SELECT
      NVL(TB_VENDEDORES.NOME, 'Vendedor Vazio') AS NOME_VENDEDOR
    , TB_VENDEDORES.BAIRRO AS BAIRRO_VENDEDOR
    , TB_CLIENTES.NOME AS NOME_CLIENTE
    , TB_CLIENTES.BAIRRO AS BAIRRO_CLIENTE
FROM
    TB_VENDEDORES
    FULL JOIN TB_CLIENTES
    ON TB_VENDEDORES.BAIRRO = TB_CLIENTES.BAIRRO

-- GREATEST:

SELECT GREATEST(10, 20, 15) FROM DUAL;
SELECT volume_compra, limite_credito, GREATEST(VOLUME_COMPRA, LIMITE_CREDITO) FROM TB_CLIENTES;

SELECT * FROM TB_NOTAS;
SELECT * FROM TB_VENDEDORES;
SELECT * FROM TB_CLIENTES;
SELECT * FROM TB_PRODUTOS;